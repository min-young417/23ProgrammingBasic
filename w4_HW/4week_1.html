<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>프로그래밍 기초 4주차 과제</title>
    <link rel="stylesheet" type="text/css" href="../style.css">
</head>
<body>
    <header class="header">
        
    </header>

    <section class="section1">
        <h1>프로그래밍 기초 4주차 과제</h1>
        <p>2023.07.19 프로그래밍 기초 방학 스터디</p>
        <br>
        <hr>
    </section>
    
    <nav class="nav">
        <ul>
        <li><a href="#post1">EMMET</a></li>
        <li><a href="#post2">블록태그와 인라인태그</a></li>
        <li><a href="#post3">flex</a></li>
        <li><a href="#post4">grid</a></li>
        <li><a href="#post5">반응형 웹</a></li>
        <li><a href="#post6">CSS 전처리기, 후처리기</a></li>
        <li><a href="#post7">JS프로토타입</a></li>
        <li><a href="#post8">DOM</a></li>
        <li><a href="#post9">use-effect</a></li>
        <li><a href="#post10">use-state</a></li>
        </ul>
    </nav>

    <section class="section2">
        <article id="post1">
            <h2><a>EMMET</a></h2>
            <p>
                Emmet은 웹 개발자들이 HTML과 CSS 코드를 빠르게 작성할 수 있도록 도와주는 플러그인이나 확장 기능이다. 웹 개발자들 
                사이에서 매우 인기 있는 도구로, 반복적인 코드 작성을 줄여 생산성을 향상시키는 데에 도움이 된다. 특정 형식의 약어를 
                사용하여 코드를 작성하는 방식을 제공한다. 예를 들어, 단축어 "div>p>span"을 입력하면 다음과 같은 코드가 생성된다.
            </p>
            <pre>
                &lt;div&gt;
                    &lt;p&gt;
                        &lt;span&gt;&lt;/span&gt;
                    &lt;/p&gt;
                &lt;/div&gt;
            </pre>
            <p>
                Emmet은 다양한 텍스트 편집기와 IDE에서 지원되며, 대부분의 웹 개발자들이 웹 사이트 및 웹 애플리케이션 개발 시 
                빠르고 효율적으로 코드를 작성하는 데에 유용하게 사용하고 있다.
            </p>
        </article>
    
        <article id="post2">
            <h2><a>블록태그와 인라인태그</a></h2>
            <p>
                블록 태그 (Block-level Elements)는 단락, 제목, 목록 등과 같이 페이지의 구조를 나타내는 요소들을 말한다. 항상 
                새로운 줄에서 시작하며, 가로 폭 전체를 차지하도록 기본적으로 설정되어 있다. 일반적으로 블록 태그를 사용하여 여러 
                요소를 수직으로 나열하는 레이아웃을 만들 수 있다.
            </p>
            <ul>
                <li>&lt;div&gt;: 일반적인 컨테이너 요소로, 스타일링을 위해 주로 사용된다.</li>
                <li>&lt;p&gt;: 단락(문단)을 나타낸다.</li>
                <li>&lt;h1&gt;, &lt;h2&gt;, ..., &lt;h6&gt;: 제목 요소로, 서로 다른 수준의 제목을 표현한다.</li>
                <li>&lt;ul&gt;: 정렬되지 않은 목록을 나타낸다.</li>
                <li>&lt;ol&gt;: 순서가 있는 목록을 나타낸다.</li>
                <li>&lt;li&gt;: 목록의 항목을 나타낸다.</li>
            </ul>
            <p>
                인라인 태그 (Inline Elements)는 텍스트의 일부 또는 줄 안에 삽입되는 요소로, 문장 내에서 스타일링 또는 하이퍼링크를 
                적용하는 데 사용된다. 인라인 요소는 콘텐츠의 크기만큼만 공간을 차지하며, 다른 인라인 요소와 같은 줄에 배치될 수 있다.
            </p>
            <ul>
                <li>&lt;span&gt;: 인라인 스타일링을 위해 사용되는 일반적인 컨테이너 요소이다.</li>
                <li>&lt;a&gt;: 하이퍼링크를 생성하는 앵커 요소이다.</li>
                <li>&lt;strong&gt; 또는 &lt;b&gt;: 텍스트를 굵게 표시한다.</li>
                <li>&lt;em&gt; 또는 &lt;i&gt;: 텍스트를 기울임꼴로 표시한다.</li>
                <li>&lt;img&gt;: 이미지를 삽입한다.</li>
            </ul>
        </article>
        
        <article id="post3">
            <h2><a>flex</a></h2>
            <p>
                Flexbox는 CSS 레이아웃을 구성하는 데 사용되는 레이아웃 모델로, 요소들을 유연하게 정렬하고 배치할 수 있게 해주는 
                기술이다. 웹 개발에서 반응형 레이아웃을 만들거나 요소들을 조직화하는 데 매우 유용하며, 복잡한 레이아웃을 간단하게 
                처리할 수 있도록 도와준다. Flexbox는 다양한 브라우저에서 잘 지원되며, 레이아웃을 쉽게 제어하고 유연한 웹 페이지를 
                만드는 데에 큰 도움이 된다. 
            </p>
            <ul>
                <li>
                    flex-direction: Flex 컨테이너 안의 Flex 아이템들을 배치하는 방향을 지정한다. 값으로는 row, column, 
                    row-reverse, column-reverse 등이 있다.
                </li>
                <li>
                    flex-wrap: Flex 아이템들이 한 줄에 배치되지 못하고 여러 줄로 나뉘는 경우를 제어한다. 값으로는 nowrap, wrap 
                    또는 wrap-reverse 가 있다.
                </li>
                <li>
                    justify-content: Flex 컨테이너 안에서 Flex 아이템들의 주축 (메인 축)을 따라 정렬 방법을 지정한다. 예를 들어, 
                    flex-start, flex-end, center, space-between, space-around 등이 있다.
                </li>
                <li>
                    align-items: Flex 컨테이너 안에서 Flex 아이템들의 교차축 (교차 축)을 따라 정렬 방법을 지정한다. 예를 들어, 
                    flex-start, flex-end, center, baseline, stretch 등이 있다.
                </li>
                <li>
                    flex-grow, flex-shrink, flex-basis: Flex 아이템들의 크기와 관련된 속성으로, Flex 컨테이너의 사용 가능한 
                    공간을 어떻게 분배할지를 조정한다.
                </li>
            </ul>
        </article>
        
        <article id="post4">
            <h2><a>grid</a></h2>
            <p>
                CSS Grid는 웹 개발에서 레이아웃을 구성하는 데 사용되는 다차원(2차원) 그리드 시스템으로, Flexbox와 함께 가장 강력한 
                레이아웃 기술 중 하나이다. CSS Grid는 Flexbox와는 달리 행(row)과 열(column)을 모두 사용하여 요소를 배치하고 
                정렬하는데 사용된다. CSS Grid는 웹 페이지의 복잡한 레이아웃을 다루는데 효과적이며, 반응형 디자인과 다양한 디바이스에 
                적합한 레이아웃을 구성하는 데 유용하다. Flexbox와 함께 사용하면 더욱 강력한 레이아웃 기능을 활용할 수 있다. 하지만 
                오래된 브라우저에서는 지원이 제한적일 수 있으므로 이러한 측면을 고려하여 사용할 수 있다.
            </p>
            <ul>
                <li>
                    grid-template-columns, grid-template-rows: 그리드 컨테이너 안의 열과 행의 크기를 정의한다. 각각의 값은 고정 
                    크기, 유연한 크기 (fr), 그리드 트랙 이름 (grid-template-areas를 사용하는 경우) 등으로 지정할 수 있다.
                </li>
                <li>
                    grid-gap 또는 gap: 그리드 아이템들 사이의 간격을 설정한다.
                </li>
                <li>
                    grid-template-areas: 그리드 영역을 이름으로 정의하고, 그리드 아이템들을 해당 영역에 배치한다.
                </li>
                <li>
                    grid-column, grid-row: 그리드 아이템의 위치를 지정하는 속성으로, 아이템이 어떤 열 또는 행에 위치할지를 설정한다.
                </li>
                <li>
                    grid-auto-columns, grid-auto-rows: 그리드 컨테이너에 추가된 그리드 아이템들의 크기를 자동으로 설정한다.
                </li>
            </ul>
        </article>
        
        <article id="post5">
            <h2><a>반응형 웹</a></h2>
            <p>
                반응형 웹은 다양한 디바이스와 화면 크기에 자동으로 최적화되는 웹 디자인 기술을 말한다. 웹 사이트나 웹 애플리케이션이 PC, 
                태블릿, 스마트폰과 같은 다양한 기기에서 모두 잘 작동하도록 만드는 것을 의미한다. 
            </p>
        </article>
        
        <article id="post6">
            <h2><a>CSS 전처리기, 후처리기</a></h2>
            <p>
                CSS 전처리기와 후처리기는 기존의 CSS를 보완하고, 개발자들이 CSS를 더 효율적이고 유지보수하기 쉽게 작성할 수 있도록 
                도와주는 도구들이다. 이들은 CSS의 기능을 확장하거나 특정 기능을 추가하여 개발자들에게 편의성을 제공한다.
            </p>
            <p>
                CSS 전처리기는 CSS를 기반으로 한 새로운 언어를 사용하여 스타일 시트를 작성하는 도구이다. 이러한 언어는 변수, 함수, 중첩 
                규칙 등과 같은 기능들을 포함하여 CSS의 기능을 확장한다. 전처리기로 작성된 스타일 시트는 컴파일러를 통해 일반적인 CSS로 
                변환되어 브라우저가 이해할 수 있는 형태로 만들어진다.
            </p>
            <p>
                CSS 후처리기는 기존의 CSS를 대상으로 여러가지 변환 작업을 수행하는 도구이다. 후처리기는 기존 CSS 파일을 가져와서 분석하고, 
                사용자가 정의한 규칙에 따라 수정된 CSS 파일을 생성한다.
            </p>
        </article>
        
        <article id="post7">
            <h2><a>JS프로토타입</a></h2>
            <p>
                모든 JavaScript 객체는 프로토타입을 가지며, 객체가 상속을 통해 다른 객체의 프로퍼티와 메서드를 공유하는 메커니즘을 제공한다. 
                이 프로토타입 객체는 해당 객체를 생성하는데 사용된 생성자(constructor) 함수의 프로토타입 속성에 연결되어 있다. 프로토타입 
                체인을 통해 객체는 프로토타입 체인을 따라 상위 프로토타입으로 이동하여 메서드와 프로퍼티를 찾을 수 있다.
            </p>
        </article>
        
        <article id="post8">
            <h2><a>DOM</a></h2>
            <p>
                DOM(Document Object Model)은 웹 페이지의 구조화된 문서를 표현하고 조작하는 데 사용되는 프로그래밍 인터페이스이다. HTML, 
                XML, 그리고 XHTML과 같은 문서들을 계층적인 트리 구조로 표현하여 웹 페이지의 요소들을 개별적으로 접근하고 조작할 수 있도록 한다.
            </p>
            <p>
                DOM은 웹 브라우저에서 웹 페이지를 불러올 때 자동으로 생성되며, JavaScript를 사용하여 DOM에 접근하고 수정할 수 있다. DOM은 웹 
                페이지의 모든 요소들을 자바스크립트 객체로 취급한다. 각 요소는 노드(Node)로 표현되며, 요소 뿐만 아니라 텍스트, 속성, 주석 등도 
                노드로 간주된다.
            </p>
            <p>
                DOM은 웹 개발에서 매우 중요한 개념으로, 웹 페이지의 동적인 기능을 구현하는 데에 빠질 수 없는 도구이다. JavaScript를 사용하여 
                DOM을 조작함으로써 사용자와 상호작용하는 웹 애플리케이션을 개발할 수 있고, 웹 페이지의 내용, 스타일, 동작 등을 동적으로 변경할 
                수 있다.
            </p>
        </article>
        
        <article id="post9">
            <h2><a>use-effect</a></h2>
            <p>
                useEffect는 React Hooks API 중 하나로, 함수형 컴포넌트에서 side effect를 다루는데 사용된다. side effect란 컴포넌트의 
                렌더링과 관련 없는 작업으로서, 주로 데이터 가져오기, 구독 설정, DOM 조작, 타이머 설정 등이 해당된다. useEffect를 사용하여 
                컴포넌트가 렌더링된 이후에 실행되는 코드를 작성할 수 있다. useEffect는 컴포넌트가 마운트(렌더링된 후), 언마운트(컴포넌트가 
                제거되기 전), 업데이트(컴포넌트의 상태나 프롭스가 변경될 때)될 때 실행될 콜백 함수를 등록하는 방식으로 동작한다. 이를 통해 
                컴포넌트의 생명주기와 관련하여 원하는 작업을 수행할 수 있다. useEffect는 여러 번 사용할 수 있으며, 두 번째 인자로 상태 변수나 
                프롭스를 전달하여 해당 값들이 변경될 때마다 콜백 함수를 실행할 수도 있다. 이를 통해 특정 상태나 프롭스가 변경될 때 원하는 동작을 
                수행할 수 있다.
            </p>
            <pre>
                import React, { useEffect } from 'react';

                function MyComponent() {
                    useEffect(() => {
                        // 여기서 원하는 부수 효과 작업을 수행합니다.
                        console.log('Component is mounted.');
                        return () => {
                            // 언마운트될 때 실행되는 콜백 함수
                            console.log('Component is unmounted.');
                        };
                    }, []); // 빈 배열을 전달하여 컴포넌트가 마운트될 때만 실행

                    return &lt;div&gt;My Component&lt;/div&gt;;
                }
            </pre>
        </article>
        
        <article id="post10">
            <h2><a>use-state</a></h2>
            <p>
                useState는 React Hooks API 중 하나로, 함수형 컴포넌트에서 상태(state)를 관리하는데 사용된다. useState를 사용하면 컴포넌트의 
                상태를 저장하고 변경할 수 있다. 상태는 컴포넌트가 렌더링되는 동안에 유지되며, 상태가 변경될 때마다 컴포넌트가 다시 렌더링된다.
            </p>
            <pre>
                import React, { useState } from 'react';

                function Counter() {
                    // useState를 사용하여 count라는 상태와 setCount라는 상태를 변경하는 함수를 생성합니다.
                    const [count, setCount] = useState(0);

                    const increment = () => {
                        setCount(count + 1); // count 상태를 1 증가시킵니다.
                    };

                    const decrement = () => {
                        setCount(count - 1); // count 상태를 1 감소시킵니다.
                    };

                    return (
                        &lt;div&gt;
                            &lt;h1&gt;Count: {count}&lt;/h1&gt;
                            &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
                            &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;
                        &lt;/div&gt;
                    );
                }
            </pre>
        </article>
    </section>
    
    <footer class="footer">
        <p>2023.7.19 프로그래밍 기초 </p>
    </footer>
</body>
</html>