<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>프로그래밍 기초 3주차 과제#1</title>
    <link rel="stylesheet" type="text/css" href="../style.css">
</head>
<body>
    <header class="header">
        
    </header>

    <section class="section1">
        <h1>프로그래밍 기초 3주차 과제#2</h1>
        <p>2023.07.11 프로그래밍 기초 방학 스터디</p>
        <br>
        <hr>
    </section>
    
    <nav class="nav">
        <ul>
        <li><a href="#post1">gdb</a></li>
        <li><a href="#post2">C언어 헤더 파일</a></li>
        <li><a href="#post3">fopen과 freopen</a></li>
        <li><a href="#post4">포인터(*)와 참조(&)의 차이</a></li>
        <li><a href="#post5">함수 포인터와 람다(익명) 함수</a></li>
        <li><a href="#post6">콜백 함수와 콜백 지옥</a></li>
        <li><a href="#post7">void 포인터와 malloc</a></li>
        <li><a href="#post8">gcc의 컴파일 과정</a></li>
        <li><a href="#post9">nasm과 AT&T</a></li>
        <li><a href="#post10">파일 리버싱</a></li>
        </ul>
    </nav>

    <section class="section2">
        <article id="post1">
            <h2><a>gdb</a></h2>
            <p>
                GDB (GNU 디버거)는 주로 C, C++, 포트란 등 다양한 프로그래밍 언어로 작성된 프로그램을 디버깅하는 
                데 사용되는 강력한 명령줄 디버거이다. 
            </p>
            <ol>
                <li>gcc -g -o 프로그램명 소스파일.c : 디버깅 심볼이 포함된 프로그램을 컴파일</li>
                <li>gdb 프로그램명 : 컴파일된 프로그램을 GDB로 실행</li>
                <li>GDB 프롬프트가 나타나면, 다양한 GDB 명령을 사용할 수 있다.</li>
            </ol>
            <ul>
                <li>run (또는 r): 프로그램 실행</li>
                <li>break (또는 b): 중단점 설정</li>
                <li>continue (또는 c): 실행 계속</li>
                <li>next (또는 n): 다음 줄로 이동</li>
                <li>step (또는 s): 다음 단계로 이동 (함수 호출 내부 진입)</li>
                <li>print (또는 p): 변수 값 출력</li>
                <li>quit (또는 q): GDB 종료</li>
            </ul>
        </article>
    
        <article id="post2">
            <h2><a>C언어 헤더 파일</a></h2>
            <p>
                C 언어에서 헤더 파일은 미리 정의된 함수와 변수의 선언, 매크로 등을 포함하는 텍스트 파일이다. 헤더 
                파일은 주로 다른 소스 파일에서 해당 함수나 변수를 사용하기 위해 필요한 정보를 제공한다. C 언어에는 
                여러 가지 표준 헤더 파일이 있으며, 또한 사용자가 직접 헤더 파일을 작성하여 필요한 선언을 포함시킬 
                수도 있다.
            </p>
            <p>
                일반적으로 자주 사용되는 몇 가지 표준 C 헤더 파일
            </p>
            <ol>
                <li>stdio.h : 입출력 함수를 포함. printf와 scanf와 같은 함수</li>
                <li>stdlib.h : 일반적인 유틸리티 함수를 포함. 동적 메모리 할당을 위한 malloc, free 함수 등</li>
                <li>string.h : 문자열 처리 함수를 포함. strcpy, strlen과 같은 문자열 조작 함수</li>
                <li>math.h : 수학 함수를 포함. sqrt, sin, cos와 같은 수학 함수</li>
                <li>time.h : 시간과 관련된 함수를 포함. time, strftime과 같은 함수</li>
            </ol>
        </article>
        
        <article id="post3">
            <h2><a>fopen과 freopen</a></h2>
            <p>
                fopen : 지정된 파일 이름(filename)과 파일 모드(mode)로 파일을 열고, 해당 파일에 대한 파일 포인터
                (FILE*)를 반환
            </p>
            <p>
                FILE* fopen(const char* filename, const char* mode)
            </p>
            <p>
                freopen : 이미 열려있는 스트림(stream)을 새로운 파일(filename)과 모드(mode)로 재지정
            </p>
            <p>
                FILE* freopen(const char* filename, const char* mode, FILE* stream)
            </p>
            <pre>
                FILE* file = fopen("example.txt", "r"); // example.txt 파일을 읽기 모드로 열기
                // 파일 내용을 읽는 작업
                fclose(file); // 파일 닫기

                file = freopen("newfile.txt", "w", file); // newfile.txt 파일을 쓰기 모드로 재지정
                // 파일에 쓰는 작업
                fclose(file); // 파일 닫기
            </pre>
            <p>
                fopen 및 freopen 함수를 사용할 때, 파일을 정상적으로 열었는지 확인하기 위해 반환된 파일 포인터를 
                NULL과 비교하여 확인하는 것이 좋다. 또한 파일 작업을 모두 마친 후에는 fclose 함수를 사용하여 파일을 
                닫는 것을 잊지 말아야 한다.
            </p>
        </article>
        
        <article id="post4">
            <h2><a>포인터(*)와 참조(&)의 차이</a></h2>
            <p>
                포인터는 변수의 주소를 저장하는 변수이다. 포인터를 사용하여 변수의 주소를 저장하고, 해당 주소에 
                접근하여 변수의 값을 변경하거나 가져올 수 있다. 역참조를 통해 해당 주소에 저장된 값을 가져올 수 
                있다. 포인터는 메모리 주소를 저장하기 때문에, 동적 메모리 할당이나 배열 등의 고급 데이터 구조를 
                다룰 때 유용하다.  언제든지 생성할 수 있으며, 다른 변수의 주소를 할당할 수 있다.
            </p>
            <p>
                참조는 이미 선언된 변수에 대한 별칭(alias)을 생성한다. 변수의 이름 앞에 참조 연산자(&)를 사용하여 
                변수의 주소를 가져올 수 있다. 이렇게 생성된 참조는 원래 변수와 동일한 메모리 위치를 가리키며, 참조를 
                통해 변경된 값은 원래 변수에 반영된다. 변수와 동일한 작업을 수행할 수 있다. NULL 값을 가질 수 없다. 
                변수 선언과 동시에 참조를 생성하고, 이후 다른 변수에 대한 참조를 만들 수 없다.
            </p>
        </article>
        
        <article id="post5">
            <h2><a>함수 포인터와 람다(익명) 함수</a></h2>
            <p>
                함수 포인터와 람다(익명) 함수는 C 언어 및 일부 C++ 버전에서 사용되는 개념이다. 이들은 함수를 
                가리키거나 익명으로 정의하여 사용할 수 있게 해준다.
            </p>
            <p>
                함수 포인터는 기존에 정의된 함수의 주소를 저장하는 변수이다. 함수 포인터를 선언하고 해당 함수의 
                주소를 할당한 후, 해당 포인터를 사용하여 함수를 호출할 수 있다. 함수 포인터 변수는 함수 이름 앞에 
                *를붙여서 선언된다. 함수 포인터는 기존에 정의된 함수의 주소를 가리키므로, 해당 함수의 유효 범위 내에서 
                사용될 수 있다. 함수 포인터는 함수의 주소를 저장하기 때문에, 해당 함수가 유효한 메모리 위치를 가리켜야 
                한다. 프로그램 실행 중에 동적으로 함수를 변경하거나 다른 함수에 할당하는 데 유용하다.
            </p>
            <p>
                람다 함수는 익명으로 정의되는 함수로, 주로 인라인으로 사용된다. 람다 함수는 필요한 기능을 함수 내부에서 
                정의하고 사용하는 방식으로 사용된다. 함수 정의를 중괄호 {}로 감싸고, 필요한 경우 매개변수를 선언하고, 
                함수 몸체를 구현한다. 람다 함수는 변수에 할당되거나 직접 호출될 수 있다. 람다 함수는 정의된 위치에서 
                유효하다. 일반적으로 해당 람다 함수를 정의한 함수 내에서 사용된다. 해당 함수의 지역 변수에 접근할 수 
                있으며, 캡처 리스트를 통해 외부 변수를 캡처할 수도 있다.
            </p>
        </article>
        
        <article id="post6">
            <h2><a>콜백 함수와 콜백 지옥</a></h2>
            <p>
                콜백 함수는 다른 함수에게 작업의 일부 또는 결과를 전달하기 위해 사용되는 함수이다. 주로 비동기 작업이 
                완료되거나 이벤트가 발생했을 때 호출된다. 일반적으로 함수 포인터를 통해 전달되며, 호출되는 시점은 호출된 
                함수의 내부 로직에 따라 결정된다.
            </p>
            <p>
                콜백 지옥은 비동기 코드에서 콜백 함수 체인이 복잡하게 중첩되어 코드의 가독성과 유지보수성을 저하시키는 
                상황을 의미한다. 비동기 작업이 여러 단계로 나누어져야 하거나 여러 개의 비동기 작업이 연속적으로 수행되어야 
                할 때, 콜백 함수를 연속적으로 중첩하면 코드가 복잡해지고 이해하기 어려워진다. 콜백 지옥은 코드의 가독성을 
                해치고 버그 발생 가능성을 높이는 요인이 될 수 있다.
            </p>
            <p>
                콜백 지옥을 해결하기 위한 방법으로는 프라미스/퓨처 패턴, 비동기/프라미스 기반 라이브러리, 비동기/프라미스를 
                지원하는 언어나 프레임워크 사용, 비동기/await-async 패턴이 있다.
            </p>
        </article>
        
        <article id="post7">
            <h2><a>void 포인터와 malloc</a></h2>
            <p>
                void 포인터와 malloc 함수는 C 언어에서 메모리 동적 할당과 관련된 기능을 다루는 데 사용된다.
            </p>
            <p>
                void 포인터는 어떤 데이터 타입의 주소도 저장할 수 있는 일반적인 포인터이다. void* 타입으로 선언되며, 
                메모리의 주소를 가리킬 수 있지만, 해당 주소에 저장된 데이터의 크기나 타입 정보는 알 수 없다. void 포인터는 
                주로 다른 포인터 타입으로 형변환할 때 사용되며, 메모리의 일부를 일시적으로 다른 타입으로 해석하고자 할 때 
                유용하다.
            </p>
            <p>
                malloc 함수는 C 언어에서 동적 메모리 할당을 위해 사용되는 함수이다. 헤더 파일 stdlib.h에 정의되어 있다. 
                지정된 크기의 메모리 블록을 할당하고, 할당된 메모리 블록의 시작 주소를 반환한다.
            </p>
            <p>
                void* malloc(size_t size);
            </p>
        </article>
        
        <article id="post8">
            <h2><a>gcc의 컴파일 과정</a></h2>
            <ol>
                <li>
                    프리프로세싱(Preprocessing) : 전처리기(preprocessor)가 소스 코드를 처리하는 단계. #include 지시문을 
                    통해 다른 파일의 내용을 포함시키거나, 매크로를 정의하고 확장하고, 조건부 컴파일 등을 수행한다. 
                </li>
                <li>
                    컴파일링(Compiling) : 컴파일러가 전처리된 소스 코드를 컴파일하는 단계. 컴파일러는 소스 코드를 어셈블리 
                    코드로 변환한다. 이 단계에서 문법 오류를 검사하고, 중간 코드를 생성한다. 
                </li>
                <li>
                    어셈블링(Assembling) : 어셈블러(assembler)가 어셈블리 코드를 기계어로 변환하는 단계. 어셈블러는 
                    어셈블리 코드를 목적 파일(object file)로 변환한다. 목적 파일은 기계어로 변환된 코드와 해당 코드의 위치 
                    정보를 포함한다.
                </li>
                <li>
                    링킹(Linking) : 링커(linker)가 여러 개의 목적 파일 및 라이브러리 파일을 결합하여 실행 가능한 바이너리 
                    파일을 생성하는 단계. 링커는 목적 파일과 라이브러리 파일 사이의 상호 의존성을 해결하고, 심볼(symbol) 
                    테이블을 생성한다. 최종적으로 실행 파일이나 공유 라이브러리를 생성하게 된다.
                </li>
            </ol>
        </article>
        
        <article id="post9">
            <h2><a>nasm과 AT&T</a></h2>
            <p>
                NASM (Netwide Assembler)은 x86 아키텍처를 위한 어셈블리 언어 컴파일러이다. NASM은 주로 Intel 구문을 
                사용하여 어셈블리 코드를 작성한다. 명령어와 레지스터의 순서가 일관되고 명시적이다. 레지스터는 목적지
                (destination)와 소스(source)의 순서로 작성된다. NASM에서는 상수 값을 표현할 때 상수 값을 직접 사용한다. 
                세미콜론(;)을 사용하여 주석을 작성한다. NASM은 명령어에 접미사를 사용하여 크기를 나타낸다. 예를 들어 mov 
                byte [eax], 42에서 byte는 바이트 크기를 나타낸다.
            </p>
            <p>
                AT&T 구문은 다른 어셈블리 언어에서 사용되는 대안 구문이다. AT&T 구문은 x86 아키텍처에서 주로 사용되며, C 
                언어와의 통합에 특화되어 있다. AT&T 구문은 명령어와 레지스터의 순서가 반대로 작성된다. 레지스터는 
                %레지스터와 같이 $레지스터로 접두어를 붙여서 사용된다. 또한 소스(source)와 목적지(destination)의 순서가 
                바뀐다. AT&T 구문에서는 상수 값을 표현할 때 $를 사용하여 구분한다. 예를 들면 mov $42, %eax와 같이 상수 
                값을 명시한다. 주석을 /* */ 형태로 작성한다. AT&T 구문에서는 대부분의 명령어에 접미사가 없으며, 대신 
                레지스터 이름에 %를 붙여서 크기를 나타낸다. 예를 들어 %al, %ax, %eax 등으로 특정 크기의 레지스터를 지정한다.
            </p>
        </article>
        
        <article id="post10">
            <h2><a>파일 리버싱</a></h2>
            <p>
                파일 리버싱(File Reversing)은 컴퓨터 프로그램 또는 바이너리 파일을 분석하여 그 동작, 내부 구조, 알고리즘 
                등을 이해하는 과정이다. 주로 악성 코드 분석, 보안 취약점 분석, 역공학 등에 활용된다.
            </p>
            <ol>
                <li>
                    정적 분석(Static Analysis) : 파일의 구조를 분석하고 이해한다. 파일 포맷, 헤더 정보, 섹션 구조 등을 
                    살펴본다. 디버거, 헥스 에디터, 바이너리 분석 도구 등을 사용하여 파일을 열고 내부 구조를 확인한다. 주요 
                    함수, 데이터 구조, 상수, 문자열 등을 식별하고 분석한다.
                </li>
                <li>
                    동적 분석(Dynamic Analysis) : 파일을 실행하고 동작을 분석한다. 동적 분석은 파일을 실제로 실행해보고 
                    동작을 모니터링하는 것을 의미한다. 디버거를 사용하여 파일을 실행하고 중단점을 설정하여 실행 흐름을 
                    추적한다. 메모리 덤프, 레지스터 값, 스택 정보 등을 분석하여 알고리즘을 이해하고 프로그램의 동작을 추적한다.
                </li>
                <li>
                    역컴파일(Decompilation) : 바이너리 코드를 소스 코드로 변환한다. 역컴파일은 원래 소스 코드를 얻는 것은 
                    아니지만, 비슷한 수준의 읽기 쉬운 소스 코드를 생성할 수 있다. 역컴파일러 도구를 사용하여 바이너리 코드를 
                    분석하고 소스 코드로 변환한다. 변환된 소스 코드를 분석하고 이해하여 프로그램의 동작과 알고리즘을 파악한다.
                </li>
                <li>
                    동적 패치(Dynamic Patching) : 파일의 동작을 변경하거나 보완하기 위해 수정 사항을 적용한다. 역컴파일된 
                    코드를 수정하여 원하는 동작을 추가하거나 보안 취약점을 수정한다. 패치된 파일을 실행하고 동작을 확인한다.
                </li>
            </ol>
        </article>
    </section>
    
    <footer class="footer">
        <p>2023.7.11 프로그래밍 기초 </p>
    </footer>
</body>
</html>