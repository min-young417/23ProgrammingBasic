<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>프로그래밍 기초 2주차 과제#2</title>
    <link rel="stylesheet" type="text/css" href="../style.css">
</head>
<body>
    <header class="header">
        
    </header>

    <section class="section1">
        <h1>프로그래밍 기초 2주차 과제#2</h1>
        <p>2023.07.04 프로그래밍 기초 방학 스터디</p>
        <br>
        <hr>
    </section>
    
    <nav class="nav">
        <ul>
        <li><a href="#post1">파일 사용자와 그룹</a></li>
        <li><a href="#post2">netstat</a></li>
        <li><a href="#post3">ufw</a></li>
        <li><a href="#post4">service</a></li>
        <li><a href="#post5">git과 SVN</a></li>
        <li><a href="#post6">branch</a></li>
        <li><a href="#post7">stash</a></li>
        <li><a href="#post8">merge</a></li>
        <li><a href="#post9">conflict</a></li>
        <li><a href="#post10">Jenkins</a></li>
        </ul>
    </nav>

    <section class="section2">
        <article id="post1">
            <h2><a>파일 사용자와 그룹</a></h2>
            <p>
                리눅스 및 유닉스 기반 시스템에서는 각 파일과 디렉토리에 소유자와 소유 그룹을 지정할 수 있다. 
                파일 사용자(user)와 파일 그룹(group)은 파일에 대한 접근 권한과 관련된 중요한 개념이다.
            </p>
            <p>
                파일 사용자 (User)는 파일을 생성한 사용자를 나타낸다. 파일 사용자는 사용자 계정에 의해 
                식별된다. 각 파일에는 파일 소유자(user)가 있으며, 소유자는 파일에 대한 읽기, 쓰기 및 실행과 
                같은 접근 권한을 갖는다. 소유자는 해당 파일에 대한 소유권과 관련하여 변경 및 조작 권한을 
                가지고 있다.
            </p>
            <p>
                파일 그룹 (Group)은 파일에 대한 접근 권한을 공유하는 사용자들의 그룹을 나타낸다. 파일 그룹은 
                사용자 계정 그룹에 의해 식별된다. 파일에는 파일 소유 그룹(group)이 있으며, 해당 그룹의 
                사용자들은 파일에 대해 동일한 접근 권한을 갖는다. 파일 그룹은 파일의 소유자와는 별도로 설정된다.
            </p>
            <p>
                파일 사용자와 파일 그룹은 파일 시스템에서 중요한 역할을 수행하며, 파일의 보안 및 접근 권한 
                관리에 영향을 미친다. 적절한 파일 사용자와 그룹 설정은 파일의 소유와 접근을 관리하고, 파일에 
                대한 보안과 데이터의 무결성을 유지하는 데 도움이 된다.
            </p>
        </article>
    
        <article id="post2">
            <h2><a>netstat</a></h2>
            <p>
                netstat은 네트워크 연결 및 네트워크 인터페이스 관련 정보를 표시하는 명령어이다. 주로 리눅스와 
                유닉스 기반 시스템에서 사용되며, 네트워크 상태를 확인하고 문제 해결에 도움을 주는 데 사용된다.
            </p>
            <p>
                netstat [옵션]
            </p>
            <p>
                -옵션-
            </p>
            <ol>
                <li>-a (all): 모든 연결 및 리스닝 포트를 표시</li>
                <li>-t (tcp): TCP 연결만 표시</li>
                <li>-u (udp): UDP 연결만 표시</li>
                <li>-n (numeric): 주소와 포트 번호를 숫자로 표시</li>
                <li>-p (process): 프로세스 ID와 함께 연결 정보를 표시</li>
                <li>-r (route): 라우팅 테이블 정보를 표시</li>
                <li>-s (statistics): 네트워크 통계 정보를 표시</li>
            </ol>
            <p>
                netstat는 일반적으로 네트워크 연결 확인, 포트 리스닝 확인, 프로세스와 연결 매핑, 네트워크 
                통계확인 등과 같은 작업에 유용하게 사용된다. 중요한 점은 netstat의 결과는 현재 시점의 네트워크 
                상태를 보여준다는 것이며, 실시간으로 변경되는 상태이기 때문에 결과를 모니터링하고 분석해야 한다.
            </p>
        </article>
        
        <article id="post3">
            <h2><a>ufw</a></h2>
            <p>
                ufw(Uncomplicated Firewall)는 Ubuntu 및 다른 Debian 기반 시스템에서 사용되는 간단한 방화벽 
                구성 도구이다. CLI(Command Line Interface) 기반으로 작동하며, 시스템 관리자가 네트워크 트래픽을 
                제어하고 보안을 강화하는 데 사용된다. ufw를 사용하여 방화벽 규칙을 추가, 제거 및 관리할 수 있으며, 
                간단한 명령어 구문을 통해 사용자 친화적인 인터페이스를 제공합니다.
            </p>
            <p>-일반적으로 사용되는 ufw 명령어-</p>
            <ol>
                <li>sudo ufw enable : ufw를 활성화하고 현재 설정된 방화벽 규칙을 적용</li>
                <li>sudo ufw disable : ufw를 비활성화하고 모든 트래픽을 허용</li>
                <li>sudo ufw allow [포트/프로토콜] : 특정 포트 또는 프로토콜을 방화벽에서 허용</li>
                <li>sudo ufw delete [포트/프로토콜] : 이전에 추가된 특정 포트 또는 프로토콜을 방화벽에서 제거</li>
                <li>sudo ufw status : 현재 적용된 방화벽 규칙과 상태를 표시</li>
                <li>sudo ufw allow from [IP 주소], sudo ufw deny from [IP 주소] : 특정 IP 주소에서의 연결을 허용 또는 차단</li>
            </ol>
            <p>
                ufw는 매우 간단하고 사용하기 쉬운 방화벽 구성 도구이다. 그러나 정확한 방화벽 규칙 및 설정은 
                시스템의 보안 요구사항에 따라 달라질 수 있으므로 신중하게 구성해야 한다. ufw를 사용하기 전에 방화벽 
                정책 및 규칙에 대해 충분히 이해하고 목적에 맞게 구성하는 것이 중요하다.
            </p>
        </article>
        
        <article id="post4">
            <h2><a>service</a></h2>
            <p>
                service는 리눅스와 유닉스 기반 시스템에서 시스템 서비스를 관리하는 명령어이다. 이 명령어는 특정 
                서비스의 시작, 중지, 재시작, 상태 확인 등 다양한 작업을 수행할 수 있다.
            </p>
            <p>service [서비스 이름] [옵션]</p>
            <p>-옵션-</p>
            <ol>
                <li>start: 서비스를 시작</li>
                <li>stop: 서비스를 중지</li>
                <li>restart: 서비스를 재시작</li>
                <li>status: 서비스의 현재 상태를 확인</li>
                <li>reload: 설정 변경을 다시로드하고 서비스를 다시 시작</li>
                <li>enable: 부팅 시 서비스를 자동으로 시작하도록 설정</li>
                <li>disable: 부팅 시 서비스를 자동으로 시작하지 않도록 설정</li>
            </ol>
            <p>
                시스템 서비스를 관리할 때 service 명령어를 사용하면 편리하고 간단한 방법으로 서비스를 제어할 수 
                있다. 서비스의 실행 상태를 확인하거나 필요에 따라 시작, 중지, 재시작 등을 수행할 수 있다.
            </p>
        </article>
        
        <article id="post5">
            <h2><a></a></h2>
            <p>
                Git은 분산 버전 관리 시스템(Distributed VCS)으로 모든 개발자가 로컬 저장소를 가지고 있으며, 
                전체 기록의 복제본을 가진다. 이는 독립적인 작업, 로컬 커밋, 브랜치 및 병합 작업을 쉽게 수행할 
                수 있음을 의미한다. 로컬 저장소를 사용하므로 대부분의 작업이 로컬에서 수행되며, 네트워크 연결이 
                필요하지 않아 작업 속도를 빠르게 할 수 있다. Git은 가볍고 브랜치 및 병합이 용이하며, 여러 
                개발자가 동시에 다른 브랜치에서 작업하고 변경 사항을 통합할 수 있다.
            </p>
            <p>
                SVN은 중앙집중식 버전 관리 시스템(Centralized VCS)으로 개발자들은 중앙 저장소에서 작업하고 
                업데이트를 받는다. 로컬 저장소가 없고 중앙 저장소에 직접 접근한다. SVN은 간단한 작업 흐름을 
                가지고 있으며, 주로 중앙 저장소에서 코드를 가져오고 업데이트하는 방식으로 작업한다. SVN에서의 
                브랜칭과 병합은 Git에 비해 제한적이고 복잡할 수 있다.
            </p>
            <p>
                Git은 대규모 프로젝트 및 분산 협업에 더 적합하며, 빠른 작업 속도와 유연한 브랜칭 및 병합을 
                제공합니다. SVN은 작은 규모의 프로젝트나 중앙 집중식 협업에 적합한 간단한 작업 흐름을 가지고 
                있습니다. 선택은 개발 프로젝트의 특성과 요구 사항에 따라 다를 수 있습니다.
            </p>
        </article>
        
        <article id="post6">
            <h2><a></a></h2>
            <p>
                Branch"는 코드의 복제 및 독립적인 작업을 위해 사용된다. 소프트웨어 개발에서 "Branch"는 
                개발자가 원본 코드에서 분기하여 독립적으로 작업할 수 있는 복제된 버전을 의미한다. 이러한 분기된 
                버전은 원본 코드와 독립적으로 변경 및 수정할 수 있으며, 각각의 브랜치에서의 작업은 서로 영향을 
                주지 않는다. 이는 동시에 다양한 기능 개발, 버그 수정, 실험 등을 수행하면서 개발자들이 서로 충돌 
                없이 작업할 수 있도록 해준다.
            </p>
            <p>
                각 브랜치는 고유한 식별자를 가지며, 개발자들은 필요에 따라 새로운 브랜치를 생성하고 해당 브랜치로 
                전환하여 작업을 수행할 수 있다. 
            </p>
            <p>create branch : 브랜치 생성</p>
            <p>check out branch : 브랜치 전환</p>
            <p>
                각 브랜치는 서로의 변경 사항을 병합할 수 있어 개발자들은 자신이 작업한 내용을 다른 브랜치로 
                통합하거나 팀원들과 협업할 수 있다. 브랜치는 소프트웨어 개발에서 코드의 병렬 작업, 테스트, 버전 
                관리, 협업 등에 중요한 역할을 한다. 브랜치를 적절하게 관리하고 사용하면 개발 작업의 효율성과 
                유연성을 높일 수 있으며, 안정성을 유지하면서 여러 기능 및 수정을 동시에 개발할 수 있다.
            </p>
        </article>
        
        <article id="post7">
            <h2><a>stash</a></h2>
            <p>
                Stash는 현재 작업 중인 변경 사항을 일시적으로 저장하는 기능이다. 아직 커밋하지 않은 변경 사항을 
                임시적으로 저장하여 다른 브랜치로 전환하거나 다른 작업을 수행할 때 유용하다. stash 명령어를 
                사용하여 변경 사항을 stash에 저장할 수 있다.  이 명령어를 실행하면 현재 작업 중인 변경 사항이 
                stash에 저장되고, 저장된 stash는 나중에 필요할 때 적용하거나 삭제할 수 있다.
            </p>
            <ol>
                <li>git stash list: 저장된 stash 목록을 표시</li>
                <li>git stash apply: 가장 최근에 저장된 stash를 적용</li>
                <li>git stash apply stash@{n}: 특정 stash를 적용</li>
                <li>git stash drop: 가장 최근에 저장된 stash를 삭제</li>
                <li>git stash drop stash@{n}: 특정 stash를 삭제</li>
                <li>git stash pop: 가장 최근에 저장된 stash를 적용하고 삭제</li>
            </ol>
            <p>
                Stash는 변경 사항을 일시적으로 보관하는 유용한 도구로, 작업의 유연성과 효율성을 높이는 데 
                도움이 된다. 변경 사항을 임시로 저장하고 다른 작업을 수행한 후에는 stash를 적용하여 변경 사항을 
                복원할 수 있다.
            </p>
        </article>
        
        <article id="post8">
            <h2><a>merge</a></h2>
            <p>
                Merge는 다른 브랜치의 변경 사항을 현재 브랜치로 통합하는 작업을 의미한다. 주로 Git과 같은 분산 
                버전 관리 시스템에서 사용되며, 다양한 개발자들이 동시에 작업하고 각자의 브랜치에서 변경 사항을 
                개발한 후, 이를 하나의 브랜치로 병합하는 데에 사용된다.
            </p>
            <p>
                Merge를 수행하면 버전 관리 시스템은 두 브랜치의 공통 조상을 기준으로 변경 사항을 비교하고 병합한다. 
                자동으로 병합되지 않는 경우 충돌(conflict)이 발생할 수 있으며, 이는 서로 다른 브랜치에서 동일한 
                파일의 동일한 부분을 수정한 경우 등에 발생할 수 있다. 충돌을 해결하고 병합을 완료해야 한다.
            </p>
            <p>
                Merge는 소프트웨어 개발에서 중요한 개념이며, 효율적이고 원활한 팀 협업과 코드 통합을 위해 사용된다. 
                Merge를 사용하여 다른 브랜치의 변경 사항을 현재 브랜치로 통합함으로써 여러 개발자가 동시에 작업하는 
                환경에서 코드의 일관성과 통합을 유지할 수 있다.
            </p>
        </article>
        
        <article id="post9">
            <h2><a>conflict</a></h2>
            <p>
                충돌(Conflict)은 버전 관리 시스템에서 병합(Merge) 작업을 수행할 때 발생할 수 있는 상황으로, 서로 
                다른 브랜치에서 동일한 파일의 동일한 부분을 수정한 경우에 발생한다. 이런 충돌은 자동으로 해결되지 
                않고, 사용자의 개입이 필요하다. 충돌이 발생하면 버전 관리 시스템은 해당 파일에 대해 다음과 같은 
                충돌 표시를 생성한다.
            </p>
            <p>
                충돌을 해결하기 위해서는 먼저 충돌이 발생한 파일을 열어 충돌 표시를 확인한다. 충돌 효시를 기반으로 
                현재 브랜치와 다른 브랜치에서의 변경 사항을 적절하게 수정하거나 통합한다. 충돌을 해결한 파일을 
                저장하고 add로 충돌 해결된 파일을 스테이징 한뒤 병합작업을 완료하고 커밋한다.
            </p>
            <p>
                충돌은 개발자들이 동시에 작업하고 병합하는 과정에서 발생할 수 있다. 충돌은 주로 버전 관리 
                시스템에서 병합 작업을 통해 서로 다른 브랜치의 변경 사항을 통합할 때 발생하므로, 충돌이 발생할 
                가능성이 있는 작업 시 다른 개발자들과의 소통과 협업이 중요하다. 충돌이 발생하면 소통을 통해 충돌을 
                해결하고 코드를 통합하여 일관성을 유지할 수 있다.
            </p>
        </article>
        
        <article id="post10">
            <h2><a>Jenkins</a></h2>
            <p>
                Jenkins는 지속적인 통합(Continuous Integration, CI) 및 지속적인 배포(Continuous Deployment, 
                CD)를 지원하는 오픈 소스 자동화 도구이다. 소프트웨어 개발 프로세스에서 빌드, 테스트 및 배포와 같은 
                작업을 자동화하고, 개발자들이 효율적으로 협업하며 안정적인 소프트웨어를 개발할 수 있도록 돕는다.
            </p>
            <p>
                Jenkins는 다양한 프로그래밍 언어와 프레임워크, 버전 관리 시스템 등을 지원하며, 다양한 플러그인을 
                통해 기능을 확장할 수 있다. 웹 기반의 사용자 인터페이스를 제공하며, 사용자는 웹 브라우저를 통해 빌드 
                및 배포 작업을 설정, 실행 및 모니터링할 수 있다.
            </p>
            <p>
                Jenkins는 지속적인 통합 및 배포를 위해 중요한 역할을 한다. 코드 변경 사항을 신속하게 빌드하고 
                테스트하며 배포하는 과정을 자동화함으로써 품질 향상, 버그 식별 및 조기 수정, 개발자간의 원활한 협업을 
                도모한다. Jenkins는 유연하고 확장 가능한 구조를 가지고 있어 다양한 개발 환경과 요구사항에 맞춰서 
                사용될 수 있다.
            </p>
        </article>
    </section>
    
    <footer class="footer">
        <p>2023.07.04 프로그래밍 기초 </p>
    </footer>
</body>
</html>