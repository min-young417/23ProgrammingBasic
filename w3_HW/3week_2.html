<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>프로그래밍 기초 3주차 과제#2</title>
    <link rel="stylesheet" type="text/css" href="../style.css">
</head>
<body>
    <header class="header">
        
    </header>

    <section class="section1">
        <h1>프로그래밍 기초 3주차 과제#2</h1>
        <p>2023.07.11 프로그래밍 기초 방학 스터디</p>
        <br>
        <hr>
    </section>
    
    <nav class="nav">
        <ul>
        <li><a href="#post1">서버-소켓 구조</a></li>
        <li><a href="#post2">클라이언트-소켓 구조</a></li>
        <li><a href="#post3">socket 함수</a></li>
        <li><a href="#post4">파일 디스크립터(소켓)</a></li>
        <li><a href="#post5">http 요청(+헤더) 과 응답(+헤더) </a></li>
        <li><a href="#post6">시스템 쓰레드</a></li>
        <li><a href="#post7">리눅스 select</a></li>
        <li><a href="#post8">리눅스 epoll</a></li>
        <li><a href="#post9">블로킹과 논블로킹</a></li>
        <li><a href="#post10">웹 서버</a></li>
        </ul>
    </nav>

    <section class="section2">
        <article id="post1">
            <h2><a>서버-소켓 구조</a></h2>
            <p>
                서버-소켓 구조(Server-Socket Architecture)는 네트워크 통신에서 서버와 클라이언트 간의 
                상호작용을 가능하게 하는 기본적인 아키텍처이다. 이 구조는 클라이언트가 서버에 요청을 보내고, 
                서버가 이를 처리하고 응답을 반환하는 방식으로 동작한다.
            </p>
            <ol>
                <li>서버는 소켓을 생성하고 특정 포트 번호에 바인딩한다.</li>
                <li>클라이언트는 서버의 IP 주소와 포트 번호에 연결하여 소켓을 생성한다.</li>
                <li>클라이언트는 서버에 요청 메시지를 소켓을 통해 전송한다.</li>
                <li>서버는 해당 요청을 수신하고, 요청을 처리하고, 응답 메시지를 생성한다.</li>
                <li>서버는 응답 메시지를 클라이언트에게 소켓을 통해 전송한다.</li>
                <li>클라이언트는 서버의 응답을 수신하고, 해당 응답을 처리한다.</li>
                <li>연결이 더 이상 필요하지 않을 때 클라이언트와 서버는 소켓 연결을 종료한다.</li>
            </ol>
            <p>
                이러한 서버-소켓 구조는 클라이언트와 서버 간의 효율적인 통신을 가능하게 한다. TCP/IP 
                프로토콜을 기반으로 동작하며, 네트워크 응용 프로그램에서 주로 사용된다. 소켓 
                프로그래밍이라고도 불리는 이 구조는 다양한 프로그래밍 언어와 라이브러리에서 지원되며, 네트워크 
                통신을 구현하는 데 사용된다.
            </p>
        </article>
    
        <article id="post2">
            <h2><a>클라이언트-소켓 구조</a></h2>
            <p>
                클라이언트-소켓 구조(Client-Socket Architecture)는 네트워크 통신에서 클라이언트가 서버와 
                상호작용하는 기본적인 아키텍처이다. 클라이언트-소켓 구조는 클라이언트가 서버로 요청을 보내고, 
                서버가 이를 처리하고 응답을 반환하는 방식으로 동작한다.
            </p>
            <ol>
                <li>
                    클라이언트는 소켓을 생성하고, 서버의 IP 주소와 포트 번호에 연결하여 서버의 소켓과 통신할 
                    수 있는 연결을 설정한다.
                </li>
                <li>
                    클라이언트는 요청 메시지를 소켓을 통해 서버에 전송한다.
                </li>
                <li>
                    서버는 클라이언트의 요청을 수신하고, 요청을 처리하고, 적절한 응답 메시지를 생성한다.
                </li>
                <li>
                    서버는 응답 메시지를 클라이언트의 소켓으로 전송한다.
                </li>
                <li>
                    클라이언트는 서버의 응답을 수신하고, 해당 응답을 처리한다.
                </li>
                <li>
                    통신이 더 이상 필요하지 않을 때 클라이언트와 서버는 소켓 연결을 종료한다.
                </li>
            </ol>
            <p>
                클라이언트-소켓 구조는 클라이언트가 서버와 효율적으로 통신할 수 있도록 한다. 클라이언트는 
                서버의 소켓과 연결하여 요청을 전송하고, 서버의 응답을 받아 처리한다. 이 구조는 TCP/IP 
                프로토콜을 기반으로 동작하며, 다양한 프로그래밍 언어와 라이브러리에서 지원되며, 네트워크 
                통신을 구현하는 데 사용한다.
            </p>
        </article>
        
        <article id="post3">
            <h2><a>socket 함수</a></h2>
            <p>
                socket 함수는 네트워크 소켓을 생성하는 데 사용되는 함수이다.
            </p>
            <pre>
                #include &lt;sys/types.h&gt;
                #include &lt;sys/socket.h&gt;
                int socket(int domain, int type, int protocol);
            </pre>
            <ul>
                <li>
                    domain: 소켓의 도메인을 지정합니다. 도메인은 소켓이 사용될 네트워크 프로토콜 체계를 
                    나타낸다. 주요 도메인은 AF_INET (IPv4)과 AF_INET6 (IPv6)이다.
                </li>
                <li>
                    type: 소켓의 타입을 지정한다. 주요 타입으로는 SOCK_STREAM 
                    (연결 지향 TCP 소켓), SOCK_DGRAM (비연결 UDP 소켓) 등이 있다.
                </li>
                <li>
                    protocol: 소켓에 사용될 프로토콜을 지정한다. 대부분의 경우 0으로 설정하여 시스템이 
                    도메인과 타입에 적합한 기본 프로토콜을 선택하도록 한다.
                </li>
            </ul>
            <p>
                socket 함수는 성공할 경우 생성된 소켓의 파일 디스크립터를 반환하며, 실패할 경우 -1을 반환한다. 
                소켓의 파일 디스크립터는 나중에 소켓과 통신하기 위해 사용된다.
            </p>
        </article>
        
        <article id="post4">
            <h2><a>파일 디스크립터(소켓)</a></h2>
            <p>
                파일 디스크립터(File Descriptor)는 운영 체제에서 열린 파일이나 소켓 등을 식별하는 데 사용되는 
                정수값이다. 파일 시스템이나 네트워크 리소스에 접근하기 위한 핸들로서 동작한다.
            </p>
            <p>
                C 언어에서 파일 디스크립터는 int 형식으로 표현되며, 양의 정수 값을 가진다. 주로 파일을 열거나 
                생성할 때, 소켓을 생성하거나 네트워크 연결을 수립할 때 파일 디스크립터가 할당된다. 파일 
                디스크립터는 시스템 내부에서 파일이나 소켓을 참조하는 데 사용되며, 해당 리소스에 대한 작업을 
                수행하기 위해 파일 디스크립터를 사용하여 접근한다.
            </p>
            <ul>
                <li>0: 표준 입력(Standard Input)</li>
                <li>1: 표준 출력(Standard Output)</li>
                <li>2: 표준 에러(Standard Error)</li>
            </ul>
            <p>
                파일 디스크립터를 사용하여 파일을 읽거나 쓰는 등의 작업을 수행할 수 있다. C 언어에서는 read, 
                write 함수를 사용하여 파일 디스크립터와 연관된 파일에서 데이터를 읽거나 쓸 수 있다. 또한 close 
                함수를 사용하여 파일 디스크립터를 닫아 리소스를 해제할 수 있다.
            </p>
        </article>
        
        <article id="post5">
            <h2><a>http 요청(+헤더) 과 응답(+헤더) </a></h2>
            <p>
                HTTP(Hypertext Transfer Protocol)는 클라이언트와 서버 간의 통신에 사용되는 프로토콜이다. HTTP 
                요청과 응답은 클라이언트와 서버 간의 상호작용을 정의하고, 데이터를 교환하는 데 사용된다. HTTP 
                요청과 응답은 각각 요청 메시지와 응답 메시지를 통해 전달된다.
            </p>
            <p>HTTP 요청은 클라이언트가 서버에게 무엇을 요청하는지를 나타낸다.</p>
            <ul>
                <li>HTTP 메소드: 요청의 종류를 나타내는 메소드 (GET, POST, PUT, DELETE 등)</li>
                <li>URI(Uniform Resource Identifier): 요청 대상 리소스의 경로를 식별합니다.</li>
                <li>HTTP 버전: 사용 중인 HTTP 프로토콜의 버전 (예: HTTP/1.1)</li>
                <li>요청 헤더: 요청과 관련된 추가 정보 (인증, 캐시 제어, 사용자 에이전트 등)</li>
                <li>요청 본문: POST 또는 PUT 메소드와 함께 전송되는 데이터</li>
            </ul>
            <pre>
                GET /api/users HTTP/1.1
                Host: example.com
                User-Agent: Mozilla/5.0
                Accept: application/json
            </pre>
            <p>HTTP 응답은 서버가 클라이언트의 요청에 대한 응답을 제공하는 것을 나타낸다.</p>
            <ul>
                <li>상태 코드(Status Code): 요청 처리 상태를 나타내는 숫자 코드 (예: 200 OK, 404 Not Found)</li>
                <li>응답 헤더: 응답과 관련된 추가 정보 (콘텐츠 유형, 캐시 제어, 서버 정보 등)</li>
                <li>응답 본문: 응답으로 반환되는 데이터</li>
            </ul>
            <pre>
                HTTP/1.1 200 OK
                Content-Type: application/json
                Cache-Control: no-cache
                Content-Length: 123
                {"id": 1, "name": "John Doe", "email": "johndoe@example.com"}
            </pre>
        </article>
        
        <article id="post6">
            <h2><a>시스템 쓰레드</a></h2>
            <p>
                시스템 쓰레드(System Thread)는 운영 체제 수준에서 관리되는 쓰레드이다. 쓰레드는 하나의 프로세스 
                내에서 동시에 실행되는 작업 단위를 의미한다. 시스템 쓰레드는 운영 체제의 쓰레드 관리 기능을 
                이용하여 생성, 스케줄링 및 동기화된다.
            </p>
            <p>
                시스템 쓰레드는 운영 체제에 의해 직접 관리된다. 운영 체제는 쓰레드의 생성, 스케줄링, 동기화, 자원 
                할당 등을 담당한다. 동시에 여러 개의 쓰레드가 실행될 수 있다. 운영 체제는 CPU 시간을 쓰레드들 
                사이에 분배하여 동시에 실행되는 것처럼 보이도록 관리한다. 시스템 쓰레드는 여러 개의 프로세서 또는 
                코어를 활용하여 병렬로 실행될 수 있다.  동시에 실행되므로 동기화 기법을 사용하여 데이터의 일관성과 
                동시 접근에 대한 제어를 수행한다. 또한, 쓰레드는 프로세스 내의 자원을 공유할 수 있다. 실행 중인 
                쓰레드 간의 전환을 위해 컨텍스트 스위칭이 필요하다. 컨텍스트 스위칭은 현재 실행 중인 쓰레드의 
                상태를 저장하고 다음 실행할 쓰레드의 상태를 복원하는 작업이다.
            </p>
            <p>
                시스템 쓰레드는 다양한 운영 체제에서 지원되며, 대부분의 프로그래밍 언어에서 시스템 쓰레드를 활용할 
                수 있는 API를 제공한다. 예를 들어, C 언어에서는 POSIX 스레드(pthread) API를 사용하여 시스템 
                쓰레드를 다룰 수 있다.
            </p>
        </article>
        
        <article id="post7">
            <h2><a>리눅스 select</a></h2>
            <p>
                리눅스의 select 함수는 I/O 이벤트를 감지하고, 여러 개의 파일 디스크립터를 모니터링하는 
                기능을 제공하는 시스템 콜이다. select는 다중 클라이언트 연결을 다루는 네트워크 서버 
                애플리케이션에서 주로 사용된다.
            </p>
            <p>
                int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
            </p>
            <ul>
                <li>nfds: 모니터링할 파일 디스크립터의 개수보다 1 큰 값 중 가장 큰 값</li>
                <li>readfds: 읽기 가능한 이벤트를 모니터링할 파일 디스크립터의 집합</li>
                <li>writefds: 쓰기 가능한 이벤트를 모니터링할 파일 디스크립터의 집합</li>
                <li>exceptfds: 에러 이벤트를 모니터링할 파일 디스크립터의 집합</li>
                <li>timeout: select 함수가 차단되지 않고 대기할 최대 시간을 지정합니다. NULL로 설정하면 무한정 대기하게 된다.</li>
            </ul>
        </article>
        
        <article id="post8">
            <h2><a>리눅스 epoll</a></h2>
            <p>
                epoll은 리눅스에서 사용되는 I/O 이벤트 알림 메커니즘이다. 다중 I/O 작업을 처리하는 데 
                사용되며, 특히 대규모 클라이언트 연결을 다루는 서버 애플리케이션에서 많은 효율성을 제공한다.
            </p>
            <p>
                epoll은 리눅스 커널의 특정 시스템 콜로 제공된다. 기본적으로 이벤트가 발생할 때까지 I/O 
                작업을 차단하지 않고 대기할 수 있으므로, 다중 클라이언트 연결에서 효율적으로 작업할 수 있다. 
                epoll은 파일 디스크립터에 대한 이벤트를 등록하고, 이벤트가 발생했을 때 애플리케이션에 알린다. 
                이벤트 유형으로는 읽기 가능, 쓰기 가능, 에러 등이 있다. 이벤트가 발생하면 애플리케이션에 알리고, 
                애플리케이션은 해당 I/O 작업을 처리할 수 있다.
            </p>
            <p>
                epoll은 다른 I/O 모델인 select와 poll과 비교했을 때 보다 효율적인 대규모 네트워크 애플리케이션을 
                구현할 수 있다. 하지만 epoll을 사용하기 위해서는 일반적으로 비동기 I/O와 이벤트 주도 프로그래밍에 
                대한 이해가 필요하다.
            </p>
        </article>
        
        <article id="post9">
            <h2><a>블로킹과 논블로킹</a></h2>
            <p>
                블로킹 (Blocking)은 기본적으로 I/O 작업이 완료될 때까지 프로그램이 대기 상태에 들어가는 것을 
                의미한다. 블로킹 I/O 작업은 호출된 함수가 반환될 때까지 해당 스레드나 프로세스가 작업을 계속 
                수행하지 않고 멈추는 것을 말한다. I/O 작업이 완료되기 전까지는 다른 작업을 수행할 수 없으며, I/O 
                작업이 끝나야 다음 코드 라인으로 진행할 수 있다.
            </p>
            <p>
                논블로킹 (Non-blocking)은 I/O 작업이 완료되지 않아도 프로그램이 대기하지 않고 다른 작업을 계속 
                수행할 수 있는 것을 의미한다. 논블로킹 I/O 작업은 호출된 함수가 즉시 반환되며, 작업이 완료되지 
                않았을 때에도 에러나 대기 상태로 빠지지 않는다. 논블로킹 모드에서는 I/O 작업이 완료되지 않았을 
                때에도 프로그램이 다른 작업을 수행하며, I/O 작업의 상태를 주기적으로 확인하여 작업을 완료할 수 
                있도록 한다.
            </p>
        </article>
        
        <article id="post10">
            <h2><a>웹 서버</a></h2>
            <p>
                웹 서버는 클라이언트로부터 HTTP 요청을 받아들이고, 해당 요청에 대한 처리를 수행하여 클라이언트에게 
                HTTP 응답을 반환하는 소프트웨어이다.
            </p>
            <p>
                웹 서버는 웹 애플리케이션을 호스팅하고, 정적 파일 (HTML, CSS, 이미지 등) 및 동적 컨텐츠 (서버 측 
                스크립트로 생성되는 데이터)를 제공하는 역할을 담당한다. 웹 서버는 클라이언트의 상태를 유지하기 위해 
                세션 관리를 수행할 수 있다. 이를 통해 로그인 정보, 장바구니 등과 같이 상태 정보를 저장하고 관리할 
                수 있다. 또 클라이언트와의 통신에서 보안을 유지하는 역할을 수행한다. HTTPS를 통한 암호화된 통신, 
                액세스 제어, 보안 패치 등 다양한 보안 기능을 제공한다.
            </p>
            <p>
                일반적으로 가장 많이 사용되는 웹 서버는 Apache HTTP Server, Nginx, Microsoft IIS 등이 있다. 
                이러한 웹 서버는 다양한 플랫폼 (리눅스, 윈도우 등)에서 실행될 수 있고, 다양한 기능과 확장성을 
                제공한다. 웹 서버는 웹 애플리케이션과 함께 사용되며, 웹 애플리케이션은 웹 서버에 의해 호스팅되고 
                웹 서버와 상호 작용하여 동적인 기능을 수행한다.
            </p>
        </article>
    </section>
    
    <footer class="footer">
        <p>2023.7.11 프로그래밍 기초 </p>
    </footer>
</body>
</html>